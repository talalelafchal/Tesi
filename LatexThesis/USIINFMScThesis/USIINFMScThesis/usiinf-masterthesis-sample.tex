\documentclass[mscthesis,20pt]{usiinfthesis}

\usepackage{lipsum}


\usepackage{listings}
\usepackage[autostyle]{csquotes} 

\lstdefinelanguage{algebra}
{morekeywords={import,sort,constructors,observers,transformers,axioms,if,
else,end},
sensitive=false,
morecomment=[l]{//s},
}



\title{Assessing Documents by Comprehension Effort } %compulsory
%\specialization{Dependable Distributed Systems}%optional
%\subtitle{Subtitle: Reinventing the World} %optional 
\author{Talal El Afchal} %compulsory
\begin{committee}
\advisor{Prof.}{Michele}{Lanza} %compulsory
\coadvisor{Prof.}{Gabriele}{Bavota}{} %optional
\end{committee}
\Day{1} %compulsory
\Month{September} %compulsory
\Year{2017} %compulsory, put only the year
\place{Lugano} %compulsory

\dedication{To my beloved} %optional
\openepigraph{Your living is determined not so much by what life brings to you as by the attitude you bring to life; not so much by what happens to you as by the way your mind looks at what happens}{Gubran Khalil Gubran} %optional

%\makeindex %optional, also comment out \theindex at the end

\begin{document}

\maketitle %generates the titlepage, this is FIXED

\frontmatter %generates the frontmatter, this is FIXED

\begin{abstract}
Recommender systems for software developers have become increasingly popular in recent years. These systems combine several methodologies to provide suggestions that meet the developer's needs. The recommender systems collect data from online resources as blogs, forums, Q\&A websites, and suggest documents or piece of code that are most likely helpful to the developers. However, these systems are not taking into consideration an important aspect as the comprehension effort which may vary depending on the document familiarity and readability. Usually developers are more interested in documents which they are familiar with. By calculating the comprehension effort, the recommender system can re-rank the documents and suggest the most comprehensive and appropriate ones to the developer. In this work, we present our approach to calculating the effort, by creating a language model able to capture a document familiarity, that we combine with the document readability. 
\end{abstract}

\begin{acknowledgements}
\end{acknowledgements}

\tableofcontents 
\listoffigures %optional
\listoftables %optional

\mainmatter

\chapter{Introduction}

	\section{Context}
	Software systems complexity is increasing, and new technologies are introduced constantly. The software developers often have to work with new technologies which they are not familiar with, and as increasingly more comes out, the amount of information that they need to know will increase. Android, for example, was introduced 10 years ago in 2007 and nowadays there are more than three million applications available on the Google store. \\
	When android started to become popular, developers had to learn this technology and to stay updated with each new version release. 
	They had to figure out how activities work in Android, and how to use several APIs to implement different tasks assigned to them. Where do they start from? Is there some tutorial on the web where they can learn how to use a specific API or can they find a piece of code that can be reused in their application? \\
	If we search on Google for an Android tutorial we will find 22 million documents \footnote{\url{https://www.google.ch/search?site=&source=hp&q=android+tutorial&oq=android+tutorial}}, even if we search for a specific field, as an Android Bluetooth tutorial \footnote{\url{https://www.google.ch/search?client=safari&rls=en&biw=1440&bih=839&q=android+bluetooth+example}}, we get 6 million documents which still a huge number.\\
	StackOverflow is one of the most popular Q\&A websites for developers, where a million of questions are tagged as Android  \footnote{\url{https://stackoverflow.com/questions/tagged/android}}. \\
	Github host more than 500 thousand Android repositories \footnote{\url{https://github.com/search?utf8=âœ“&q=android&type=}}, with millions of lines of code. Those numbers are gigantic, and it is obvious that finding the most suitable document is not obvious, since given the big number of available documents it is not feasible for the developer to check all of them and choose the right one.\\
	Searching for documentation and tutorials is a crucial step in learning a new technology. The developers can find a bunch of online resources as blogs, forums, Q\&A websites, but the real challenge is to find the most suitable one for their needs.

\newpage
	\citep{Singer-1997} reported in 1997 that the most frequent developer activity was code search, and \citep{Sadowski:2015} did a case study on how developers at Google search for code. They figured out that programmers are generally seeking answers to questions about how to use an API, what code does, why something is failing, or where the code is located. The interesting point in this study was the fact that most searches focus on code that is familiar or somewhat familiar to the developers.\\
	Therefore, we believe that recommender systems for software developers have to take into consideration the familiarity of a document when they suggest it to the developer. But first, we have to mention the proposed definition by the organizers of the ACM International Conference on Recommender Systems:\footnote{\url{https://recsys.acm.org/recsys09}} \\

	  \blockquote{\textit{``Recommendation systems are software applications that aim to support users in their decision-making while interacting with large information spaces. They recommend items of interest to users based on preferences they have expressed, either explicitly or implicitly. The ever-expanding volume and increasing complexity of information [...] has therefore made such systems essential tools for users in a variety of information seeking [...] activities. Recommendation systems help overcome the information overload problem by exposing users to the most interesting items, and by offering novelty, surprise, and relevance.''}}
	Now that we defined what is a recommender system, we can mention the recommender systems for software engineering (RSSE) definition given by \citet{RecommendationSystemsforSoftwareEngineering}:\\

	\textbf{An RSSE is a software application that provides information items estimated to be valuable for a software engineering task in a given context.}\\

	The RSSE definition highlights the importance of the \textbf{context} and the \textbf{valuable information}, therefore RSSEs are an important support for programmers to find the information they should know, and the RSSEs have to consider and evaluate alternative decisions. We believe that effort to comprehend a document must be a part of the document evaluation.\newpage


	Understanding a document is a cognitive process, and it depends on the human brain intelligence, but we all agree that if we are familiar with a subject, we will comprehend it with less effort. A computer engineer comprehends a document that explains how to implement a sorting algorithm, with much less effort compared to a document that explains a constitutional law, and the reason is not that the algorithm is not complex, but because a computer engineer is more familiar with sorting algorithms.\\
	
	In this study, we go further than this, and we try to evaluate more interesting situations, as for example:\\
	Given two documents that have the same subject, how can we decide which one is easier to comprehend?\\
	In order to answer this question we need to introduce two concepts:
	\begin{itemize}
	\item \textbf{familiarity}: how much are we familiar with the document content?
	\item \textbf{readability}: how difficult is it to read the document?
	\end{itemize}
	The comprehension effort can be derived from the document familiarity and readability.\\

	For example, if we have two documents where, in the first one we have a sorting algorithm implemented in Java, and in the second one a sorting algorithm implemented in Fortran, and the developer is more familiar with Java. And we want to use a tool that gives us a score that indicates which document requires less effort to be comprehended, where a higher score indicates a big effort.\\
	We expect that the first document must have a lower score since logically it requires less effort to be comprehended by developers who are more familiar with Java.\\
	What if both documents have a sorting algorithm implemented in the same programing language? which one will have a lower score? \\
	In this case, the document readability will have a big impact on the comprehension effort.\\
	Certainly, the developer will prefer to read the document with the best readability.\\
	
	\section{Objective and Results}
	Our main goal in this thesis is to assess documents by their comprehension effort, which can be used by RSSE to improve their suggestions.\\
	In order to calculate the comprehension effort, we need to find a way to calculate the familiarity, and we need to evaluate our approach to understand if it effectively works.\\

	 As a first step, we select a big set of documents, which represent the hypothetical developer knowledge, where each document contains code and natural language. Then we create a \textbf{ Language Model} that we train with these documents. In this way, we were able to simulate a programmer who is familiar with these documents. Once we trained the language model, we were able to evaluate the familiarity of a given set of documents.\\ In this experiment, the language model approach satisfied our expectation in capturing the document familiarity.\\

	 On the top of this experiment, we did a case study, where we give a set of tutorials to a programmer, and after reading the tutorials, the programmer was asked to evaluate a set of documents, some of them are related to the tutorials and some are not. The evaluation is based on the comprehension effort, by giving a score between 0 and 5 \dots 


	\section{Structure of the Thesis}
	This thesis consists of seven chapters: 
	\begin{enumerate}
	
		\item \textbf{Introduction}
		\item \textbf{State of the Art} describes the existing related work as code search engines and recommender systems.
		\item \textbf{Approach} describes our approach to calculate the comprehension effort.
		\item \textbf{Study design} in this chapter we discuss the research question, the data extraction process, and the analysis method, and the replication package 
		\item \textbf{Result} describes and discuss our experiment and case study results and their implication.
		\item \textbf{Threat to Validity} describes our assumptions, and the possible threats that could affect the results validity.
		\item \textbf{Conclusion} this chapter is a summarization of our work, where we present some ideas for a possible future work.
	\end{enumerate}
\chapter{State of the Art}
	\section{Semantics Code Search}
	\section{Code Search Engines}
	\section{Libra}

\chapter{Approach}
	\section{Overview}
	\section{Language Model}
	\section{Stormed Island Parser}
	\section{Training the Language Model}
	\section{Accounting for Readability}

\chapter{Study Design}
	\section{Research Questions}
	\section{Data Collection and Analysis}	
	\section{Replication Package}

\chapter{Results}

\chapter{Threats to Validity}

\chapter{Conclusion}

\chapter[Short title]{A chapter title which will run over two lines --- it's for
  testing purpose}

\lipsum[1-2]

\section{The first section}
\lipsum[3-4]

 \section{The second, math section}

\textbf{Theorem 1 (Residue Theorem).}
Let $f$ be analytic in the region $G$ except for the isolated singularities $a_1,a_2,\ldots,a_m$. If $\gamma$ is a closed rectifiable curve in $G$ which does not pass through any of the points $a_k$ and if $\gamma\approx 0$ in $G$ then
\[
\frac{1}{2\pi i}\int_\gamma f = \sum_{k=1}^m n(\gamma;a_k) \text{Res}(f;a_k).
\]
\textbf{Theorem 2 (Maximum Modulus).}
\emph{Let $G$ be a bounded open set in $\mathbb{C}$ and suppose that $f$ is a continuous function on $G^-$ which is analytic in $G$. Then}
\[
\max\{|f(z)|:z\in G^-\}=\max \{|f(z)|:z\in \partial G \}.
\]

\section[third]{A very very long section, titled ``The third section'', with
  a rather  short text alternative (third)}
\lipsum \texttt{Some Test}
\lstset{language=algebra,linewidth=0.95\linewidth,breaklines=true,numbers=left,
basicstyle=\ttfamily,numberstyle=\tiny,escapeinside={//*}{\^^M},
mathescape=true}
\begin{lstlisting}
import IntSpec, ItemSpec;

sort cart; //*\label{sort}

constructors //*\label{begin-sig}
create() $\longrightarrow$ cart;
insert(cart, item) $\longrightarrow$ cart;
observers
amount(cart) $\longrightarrow$ int;
transformers
delete(cart, item) $\longrightarrow$ cart; //*\label{end-sig}

axioms //*\label{begin-axioms}
forall c: cart, i, j: item 

amount(create()) $=$ 0; //*\label{begin-amount}
amount(insert(c,i)) $=$ amount(c) $+$ price(i); //*\label{end-amount}
delete(create(),i) $=$ create(); //*\label{begin-delete}
delete(insert(c,i),j) $=$
if (i =$\:$= j) c
else insert(delete(c,j),i); //*\label{end-axioms}
end
\end{lstlisting}

As you can easily see from the above listing \citet{bbggs:iet07}
define something weird based on the BPEL specification
\citep{bpelspec}.
\cite{}
\nocite{*}

\appendix %optional, use only if you have an appendix

\chapter{Some retarded material}
\section{It's over\dots}
\lipsum 

\backmatter

\chapter{Glossary} %optional

%\bibliographystyle{alpha}
%\bibliographystyle{dcu}
\bibliographystyle{plainnat}
\bibliography{biblio}

%\cleardoublepage
%\theindex %optional, use only if you have an index, must use
	  %\makeindex in the preamble
\lipsum

\end{document}
